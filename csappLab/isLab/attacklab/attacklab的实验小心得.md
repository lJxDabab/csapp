attacklab的实验小心得（因为整理时间有点久了，找不到原来写过的attacklab了）

第一类的ctarget感觉像一张白纸，然后往里面插你的代码，主要方式就是往返回地址里面放入你想跳转的函数的地址（你想插入的函数），然后就可以了，如果想去设置参数的话（改变里面的rdi,rsi这类的），那么就跳入这个buf里面，然后在buf里面写入你希望设置参数命令的二进制表示就好了，但如何跳入这个buf呢？我们知道每当出现函数调用的时候，内存会在栈里面分配一个空间，这个过程通过rsp的递减来实现，因此，我们只要找到程序进行到这个函数开始的附近位置，利用gdb读出rsp的的大小就能知道buf所在的位置，从而可以进行操控了。

需要注意的是，我们大多数机器都是小端法，因此程序是以字节为单位逆向输入的逆向输入的，如图：

![image-20211220134017295](C:\Users\LJX\AppData\Roaming\Typora\typora-user-images\image-20211220134017295.png)

<img src="C:\Users\LJX\AppData\Roaming\Typora\typora-user-images\image-20211220144536192.png" alt="image-20211220144536192" style="zoom: 67%;" />

，而我们所平时看到的汇编机器代码却没有这么做，而只有地址会这么做，这是因为我们的汇编机器代码是已经小端法表示的结果。

![image-20211220144749148](C:\Users\LJX\AppData\Roaming\Typora\typora-user-images\image-20211220144749148.png)

如图，下方的地址实际为55 61 dc 78

如果再往下写，则会触及到父函数的栈帧，举个不太恰当的例子，当你main函数调用一个函数时，main函数就是该函数的父函数。当你想插入的hacker函数里面又要调用需要分配栈帧的函数时，有时则会覆盖原来这个buf里面你插入的数据（如上图来说就是那些0000000000的区域），当你需要传入一个指针，字符串类似需要存入到内存中的东西时，这时可就糟糕了，因为新分配的栈帧谁知道会不会把你的数据覆盖呢？所以我们可以顺势写入父函数的栈帧，<img src="C:\Users\LJX\AppData\Roaming\Typora\typora-user-images\image-20211220145810864.png" alt="image-20211220145810864" style="zoom:50%;" />

(F stand for 父栈帧)

因为为了使程序继续进行，你插入的函数到最后返回仍然会返回到父函数，因此尝试写入到父函数的栈帧里面保存是可以尝试的。

----

接下来的rtarget就增加了一些防御手段了。

首先1.程序执行的地址被随机化了，每次执行的地址，都是不一样的，当你每次千辛万苦打了断点或者别的啥的找到了rsp的地址，然后通过hex2raw(官方给的把二进制文件转化成电脑看得懂的字符串的程序)，找到了攻击代码，然后再执行，此时rsp对应的地址早换了，你的输入几乎肯定是无效的。

2.程序只可读

也就是，内存里面会有一个符号的标记位，（只可读，可写入和执行）去限制程序不允许栈帧里面插入可执行程序，保存堆栈的内存部分标记为不可执行文件，这样你也不能随便插入函数啦。

这时我们就需要用到面向返回的编程（rop,return-oriented programming）来攻击。大概原理是这样的，

![image-20211220152453225](C:\Users\LJX\AppData\Roaming\Typora\typora-user-images\image-20211220152453225.png)

因为每一个汇编语言的字节，拆开，组合，会有不同的意义，因此我们完全可以跳转到程序本身的地址上面去，程序自身命令的汇编出来的字节，也可以拆开，然后截取一部分来实现我们想实现的目的，并且

![image-20211220152654937](C:\Users\LJX\AppData\Roaming\Typora\typora-user-images\image-20211220152654937.png)

看看一个例子：

![image-20211220153030587](C:\Users\LJX\AppData\Roaming\Typora\typora-user-images\image-20211220153030587.png)

在上述图里面我们要把一个立即数放进rdi里面，因此我们可以在buf的返回地址上面写入该数(随后的部分往栈帧的高处写，也就是父函数，爷爷函数的栈帧)（此时这个部分本来就是可写的）（而我们之所以往栈帧上面写，是因为你pop只能让rsp增加）。然后把它pop到rax里，再把rax mov到rdi中。我们找到在addbal_219里面，可以截取一段代码，58 90 c3可以达到一部分目的，因此我们截取。此时我们在返回地址处写入的是该函数原地址处加上4，因为我们从58这个字节开始读，而不是从该函数开始的80。此时ret弹出的是我们写入的下一个gadget的地址。如下图，我们观察，进入4019ab后（这个位置是buf的返回地址），首先先pop出我们存储的立即数，也就是59b997fa,随后ret弹出一个地址，也就是下一个gadgets的开始的地址。最后的最后，数据都注入齐了，我们进入touch2,此时的touch2函数不在栈帧里。                     <img src="C:\Users\LJX\AppData\Roaming\Typora\typora-user-images\image-20211220153737462.png" alt="image-20211220153737462" style="zoom:50%;" />

因为你想要的完整的代码不可能在一段程序里面找到，因此我们需要跳转到不同的代码段里面，所以每一个gadget里面最后一个命令为ret，然后不断通过栈帧里面写入的地址不断弹出，到下一个gadget里面。![image-20211220152709678](C:\Users\LJX\AppData\Roaming\Typora\typora-user-images\image-20211220152709678.png)